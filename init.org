#+Title: GNU Emacs Configuration
#+AUTHOR: Fabian Köhler
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

#+BEGIN_SRC emacs-lisp
(defun tangle-init ()
 (when (equal (buffer-file-name)
              (expand-file-name (concat user-emacs-directory "init.org")))
   (let ((prog-mode-hook nil))
     (org-babel-tangle)
     (byte-compile-file (concat user-emacs-directory "init.el")))))

(add-hook 'after-save-hook 'tangle-init)
#+END_SRC

* Packages
#+BEGIN_SRC emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(straight-use-package 'use-package)
(setq straight-use-package-by-default t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :height 90)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :config
  (setq initial-buffer-choice (lambda () (switch-to-buffer "*dashboard*")))
  :init
  (dashboard-setup-startup-hook))
#+END_SRC

* Global
  I know it is an eternal discussion, but I use whitespaces instead of tabs.
  #+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  #+END_SRC
  
  Next, I disable the clunky interface of emacs, i.e. the menu bar, the scroll bar and the tool bar.
  #+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (toggle-scroll-bar -1)
  (tool-bar-mode -1)
  #+END_SRC
  
  When jumping words using the =w= and =b= keys in command mode, I like to also jump within a word/variable that uses camelcase.
  #+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'subword-mode)
  #+END_SRC

  Emacs has a nice feature to mark scripts executable when saving.
  It will automatically detect whether a [[https://en.wikipedia.org/wiki/Shebang_(Unix)][shebang]] is present and set the corresponding flag.
  #+BEGIN_SRC emacs-lisp
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
  #+END_SRC
  
  On a modern computer with a lot of memory, it can be benefitial for the editor performance when the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Garbage-Collection.html][garbage collection]] is not run so often.
  The next statement will start it only every =64MB=.
  #+BEGIN_SRC emacs-lisp
  (setq-default gc-cons-threshold 67108864)
  #+END_SRC
  
  When asking for confirmation there are both questions where you have to type =yes= / =no= and ones where =y= / =n= is sufficient.
  Due to laziness I prefer the second kind.
  #+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
  ;; determine how dired lists files
  (setq-default dired-listing-switches "-lah")
  
  ;; turn on syntax highlighting whenever it is possible
  (global-font-lock-mode t)
  
  ;; always reload files that change
  (global-auto-revert-mode t)
  
  ;; show matching parentheses immediately
  (show-paren-mode 1)
  (setq-default show-paren-delay 0.0)
  
  ;; highlight current line
  (require 'hl-line)
  (global-hl-line-mode)
  
  ;; show whitespaces and newlines
  (require 'whitespace)
  
  ;; clipboard
  (setq-default select-enable-clipboard t)
  (setq-default interprogram-paste-function 'x-cut-buffer-or-selection-value)
  
  ;; change location of customizations and protect init.el
  (setq-default custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file 'noerror)
  
  ;; wind move for window navigation
  (when (fboundp 'windmove-default-keybindings)
    (windmove-default-keybindings))
  #+END_SRC
  
  #+BEGIN_SRC emacs-lisp
    (setq save-interprogram-paste-before-kill t)
    (setq mouse-yank-at-point t)
    (setq require-final-newline t)
  #+END_SRC
   
** Editor Behavior
   Automatically clean whitespaces on save.
   #+BEGIN_SRC emacs-lisp
   (use-package whitespace-cleanup-mode
     :init (global-whitespace-cleanup-mode))
   #+END_SRC
   
   Automatically indent code, specify desired modes
   #+BEGIN_SRC emacs-lisp
   (use-package aggressive-indent
     :hook ((emacs-lisp-mode . aggressive-indent-mode)
            (css-mode . aggressive-indent-mode)
            (html-mode . aggressive-indent-mode)
            (latex-mode . aggressive-indent-mode)))
   #+END_SRC
* Vim-like Behavior
  I am a vim user and want to work in a similar fashion with emacs as well.
  #+BEGIN_SRC emacs-lisp
  (use-package evil
    :config
    (setq evil-want-C-d-scroll t)
    (setq evil-want-C-u-scroll t)
    (define-key evil-normal-state-map (kbd "C-u") 'evil-scroll-up)
    (define-key evil-visual-state-map (kbd "C-u") 'evil-scroll-up)
    (define-key evil-insert-state-map (kbd "C-u")
      (lambda ()
        (interactive)
        (evil-delete (point-at-bol) (point))))
    :init (evil-mode 1))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
  ;; use escape key to cancel
  (global-set-key [escape] 'keyboard-escape-quit)
  (define-key isearch-mode-map [escape] 'isearch-abort)
  (define-key isearch-mode-map "\e" 'isearch-abort)
  #+END_SRC
  
** Comments
   The [[https://github.com/linktohack/evil-commentary][evil-commentary]] package is a port of [[https://github.com/tpope][tpope]]'s awesome [[https://github.com/tpope/vim-commentary][vim-commentary]] plugin and allows for easy commenting and uncommenting of code.
   Type =gcc= to toggle the comment status of the current line when in command mode.
   =gc= does the same for visual mode.
   #+BEGIN_SRC emacs-lisp
   (use-package evil-commentary
     :init (evil-commentary-mode))
   #+END_SRC
  
** Org-Mode
   #+BEGIN_SRC emacs-lisp
     (use-package evil-org
       :config
       (add-hook 'org-mode-hook 'evil-org-mode)
       (add-hook 'evil-org-mode-hook
                 (lambda ()
                   (evil-org-set-key-theme)))
       (require 'evil-org-agenda)
       (evil-org-agenda-set-keys))
   #+END_SRC
  
** Vinegar
   Next, we implement something to resemble [[https://github.com/tpope][tpope]]'s awesome [[https://github.com/tpope/vim-vinegar][vim-vinegar]] plugin.
   This makes navigating the filesystem in =dired= much easier and renders plugins like [[https://github.com/jaypei/emacs-neotree][neotree]] useless.
   Press =-= when in command mode to open dired for the current directory, press =-= again to go one directory up.
   We also bind the vim navigation keys to work correctly in dired.
   #+BEGIN_SRC emacs-lisp
   (defun vinegar/top ()
     "Go to the top of the dired buffer"
     (interactive)
     (goto-char (point-min))
     (dired-next-line 1))
   
   (defun vinegar/bottom ()
     "Go to the bottom of the dired buffer"
     (interactive)
     (goto-char (point-max))
     (dired-next-line -1))
   
   (defun vinegar/up ()
     "Go one entry up in dired"
     (interactive)
     (dired-previous-line 1)
     (if (bobp) (dired-next-line 1)))
   
   (defun vinegar/down ()
     "Go one entry down in dired"
     (interactive)
     (dired-next-line 1)
     (if (eobp) (dired-next-line -1)))
   
   (defun vinegar/parent-dir (&optional window)
     "Jump to parent dir using dired"
     (interactive "P")
     (let* ((dir (dired-current-directory))
   	 (orig (current-buffer))
   	 (up (file-name-directory (directory-file-name dir))))
       (or (dired-goto-file (directory-file-name dir))
   	(and (cdr dired-subdir-alist)
   	     (dired-goto-subdir up))
   	(progn
   	  (kill-buffer orig)
   	  (dired up)
   	  (dired-goto-file dir)))))
   
   (defun vinegar/init ()
     "Setup vim-vinegar like keybindings for dired"
     (define-key dired-mode-map (kbd "j") 'vinegar/down)
     (define-key dired-mode-map (kbd "k") 'vinegar/up)
     (define-key dired-mode-map (kbd "-") 'vinegar/parent-dir)
     ;; (define-key dired-mode-map (kbd "g g") 'vinegar/top)
     (define-key dired-mode-map (kbd "G") 'vinegar/bottom)
     (define-key dired-mode-map (kbd "d") 'dired-create-directory)
     (define-key dired-mode-map (kbd "% s") 'find-file))

   (add-hook 'dired-mode-hook 'vinegar/init)
   (define-key evil-normal-state-map (kbd "-") 'dired-jump)
   #+END_SRC

** Line Numbers
   #+BEGIN_SRC emacs-lisp
   (use-package nlinum
     :config
     (setq nlinum-format "%4d\u2502")
     (setq nlinum-highlight-current-line 1)
     :init
     (global-nlinum-mode))
   #+END_SRC

* Version Control
* Project
  #+BEGIN_SRC emacs-lisp
    (use-package projectile
      :init (projectile-global-mode))
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  #+END_SRC
  
** Version Control
  The [[https://github.com/magit/magit][magit]] plugin is a nice tool to work with the [[https://git-scm.com/][git]] version control system from within emacs.
  For now we just install it and also throw [[https://github.com/emacs-evil/evil-magit][evil-magit]] into the mix, which makes it play nicely with [[https://github.com/emacs-evil/evil][evil-mode]].
  #+BEGIN_SRC emacs-lisp
  (use-package magit)
  (use-package evil-magit)
  #+END_SRC
* Language Support
** Language Server Protocol
    #+BEGIN_SRC emacs-lisp
      (use-package lsp-mode
        :config (setq lsp-message-project-root-warning t))

      (use-package lsp-ui
        :hook (lsp-mode-hook . lsp-ui-mode))
    #+END_SRC

** Company
  #+BEGIN_SRC emacs-lisp
  (use-package company
    :config
    ;; do not wait to complete
    (setq company-idle-delay 0)
    :init
    (global-company-mode))

  (use-package company-quickhelp
    :init
    (company-quickhelp-mode))
 
  ;; use language server protocol in company-mode
  (use-package company-lsp
    :init
    (push 'company-lsp company-backends))
  #+END_SRC

** Ansible YAML
  #+BEGIN_SRC emacs-lisp
  (use-package ansible)
  #+END_SRC
 
** C/C++
  #+BEGIN_SRC emacs-lisp
  (use-package cquery
    :config (setq cquery-executable "/usr/bin/cquery"))
  #+END_SRC
 
** C#
#+BEGIN_SRC emacs-lisp
  (use-package omnisharp
    :init
    '(add-to-list 'company-backends #'company-omnisharp)
    (defun my-csharp-mode-setup ()
      (omnisharp-mode)
      (company-mode)
      (flycheck-mode)

      (setq indent-tabs-mode nil)
      (setq c-syntactic-indentation t)
      (c-set-style "ellemtel")
      (setq c-basic-offset 4)
      (setq truncate-lines t)
      (setq tab-width 4)
      (setq evil-shift-width 4)

      (electric-pair-local-mode 1) ;; Emacs 25

      (local-set-key (kbd "C-c r r") 'omnisharp-run-code-action-refactoring)
      (local-set-key (kbd "C-c C-c") 'recompile))
      (add-hook 'csharp-mode-hook 'my-csharp-mode-setup t))
#+END_SRC

** CMake
#+BEGIN_SRC emacs-lisp
(use-package cmake-mode)
#+END_SRC
** Docker
#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :config
    (add-to-list 'auto-mode-alist
                 '("Dockerfile\\'" . dockerfile-mode)))

#+END_SRC
** Fortran
   #+BEGIN_SRC emacs-lisp
     ;; (require 'projectile)

     ;; (lsp-define-stdio-client fortls "fortran"
     ;;                          #'projectile-project-root
     ;;                          (list "fortls" "--lowercase_intrinsics"))
     ;; (add-hook 'f90-mode #'fortls-enable)
   #+END_SRC
   #+BEGIN_SRC emacs-lisp
     (setq-default f90-do-indent 4)
     (setq-default f90-if-indent 4)
     (setq-default f90-type-indent 4)
     (setq-default f90-program-indent 4)
     (setq-default f90-continuation-indent 4)
     (setq-default f90-smart-end 'blink)
   #+END_SRC
 
** Git
  #+BEGIN_SRC emacs-lisp
  (use-package gitconfig-mode)
  (use-package gitignore-mode)
  #+END_SRC
 
** Go
  #+BEGIN_SRC emacs-lisp
  (use-package go-mode)
  #+END_SRC
 
** Graphviz
  #+BEGIN_SRC emacs-lisp
  (use-package graphviz-dot-mode)
  #+END_SRC
 
** Haskell
  #+BEGIN_SRC emacs-lisp
  (use-package haskell-mode)
  #+END_SRC
 
** Julia
  #+BEGIN_SRC emacs-lisp
    ;; (require 'julia-mode)
    ;; (require 'ess-site)
    ;; (require 'ess-julia)
  #+END_SRC

** LaTeX
  #+BEGIN_SRC emacs-lisp
  ;; (require 'auctex)
  ;; (require 'company-auctex)
  ;; (setq TeX-auto-save t)
  ;; (setq TeX-parse-self t)
  ;; (setq-default TeX-master nil)
  ;; (add-hook 'LaTeX-mode-hook
  ;;           (progn
  ;;             (company-auctex-init)
  ;;             (setq evil-shift-width 2)))
  (defun set-latex-evil-shift-width ()
    "set the correct shift width for evil in latex-mode"
    (interactive)
    (setq evil-shift-width 2))
  (add-to-list 'auto-mode-alist '("\\.tex\\'" . latex-mode))
  (add-hook 'latex-mode-hook 'set-latex-evil-shift-width)
  #+END_SRC
 
** Python
   #+BEGIN_SRC emacs-lisp
     (let ((anaconda-bin-path (expand-file-name "~/.local/opt/anaconda3/bin")))
       (if (file-directory-p anaconda-bin-path)
           (progn
             (setenv "PATH" (concat anaconda-bin-path ":" (getenv "PATH")))
             (push anaconda-bin-path exec-path))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (let ((anaconda-env-path (expand-file-name "~/.local/opt/anaconda3/envs")))
       (if (file-directory-p anaconda-env-path)
           (setenv "WORKON_HOME" anaconda-env-path)))

     (use-package pyvenv
       :init
       (pyvenv-mode 1))
   #+END_SRC
  
   #+BEGIN_SRC emacs-lisp
     (let ((anaconda-env-path (expand-file-name "~/.local/opt/anaconda3/envs/pyls")))
       (if (file-directory-p anaconda-env-path)
           (pyvenv-workon "pyls")))
   #+END_SRC
  
   #+BEGIN_SRC emacs-lisp
     (defvar lsp-python-log-dir)
     (setq lsp-python-log-dir (expand-file-name "~/.emacs.d/logs/lsp-python"))

     (defvar lsp-python-log-file)
     (setq lsp-python-log-file (concat lsp-python-log-dir "/pyls.log"))

     (make-directory lsp-python-log-dir t)
   #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package lsp-python
      :hook (python-mode . lsp-python-enable))
  #+END_SRC

  
** Web
  #+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.css\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.scss\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.js?\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.jsx?\\'" . web-mode))
    :init
    (add-hook 'web-mode-hook
              (lambda ()
                (setq evil-shift-width 2)
                (setq indent-tabs-mode nil)
                (setq web-mode-markup-indent-offset 2)
                (setq web-mode-css-indent-offset 2)
                (setq web-mode-code-indent-offset 2))))
  #+END_SRC
 
** YAML
  #+BEGIN_SRC emacs-lisp
  (use-package yaml-mode)
  #+END_SRC
     
* Tools
** systemd
    #+BEGIN_SRC emacs-lisp
    (use-package systemd)
    #+END_SRC emacs-lisp

* Linting
  #+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :init (global-flycheck-mode))
  #+END_SRC

* Visuals
** Theme
   #+BEGIN_SRC emacs-lisp
   (use-package monokai-theme
     :config (load-theme 'monokai t nil))
   #+END_SRC
  
** Beacon
   #+BEGIN_SRC emacs-lisp
   (use-package beacon
     :config
     (setq beacon-color "#657b83")
     (setq beacon-size 30)
     (setq beacon-blink-duration 0.1)
     (setq beacon-blink-duration 0.05)
     :init
     (beacon-mode 1))
   #+END_SRC

** Emojis
    #+BEGIN_SRC emacs-lisp
    (use-package emojify
      :config
      (add-hook 'after-init-hook #'global-emojify-mode))
    #+END_SRC
** All the Icons
   # #+BEGIN_SRC emacs-lisp
   #   (use-package all-the-icons)
   #   (use-package all-the-icons-dired
   #     :hook (dired-mode . all-the-icons-dired-mode))
   # #+END_SRC
  
** Powerline
   #+BEGIN_SRC emacs-lisp
   ;;(require 'powerline)
   ;;(require 'spaceline)
   ;;(require 'spaceline-all-the-icons)
   ;;(setq spaceline-all-the-icons-separator-type 'wave)
   ;;(spaceline-all-the-icons-theme)
   #+END_SRC
** Indent Guides
   #+BEGIN_SRC emacs-lisp
   (use-package highlight-indent-guides
     :config
     (setq highlight-indent-guides-method 'column)
     :hook (prog-mode . highlight-indent-guides-mode))
   #+END_SRC

** Org-Mode
   #+BEGIN_SRC emacs-lisp
   (use-package org-bullets
     :hook (org-mode . org-bullets-mode))
   #+END_SRC
  
** Pretty Mode
   #+BEGIN_SRC emacs-lisp
   (setq prettify-symbols-unprettify-at-point 'right-edge)
   (global-prettify-symbols-mode +1)
   #+END_SRC

*** C++
    #+BEGIN_SRC emacs-lisp
    (defun pretty-mode/c ()
      "Prettify symbols in C mode."
      (setq prettify-symbols-alist
            (append prettify-symbols-alist
                    '(("!=" . ?≠)
                      ("<=" . ?≤)
                      (">=" . ?≥)
                      ("&&" . ?∧)
                      ("||" . ?∨)
                      ("<<" . ?≪)
                      (">>" . ?≫)))))

    (defun pretty-mode/c++ ()
      "Prettify symbols in C++ mode."
      (pretty-mode/c))

    (add-hook 'c-mode 'pretty-mode/c)
    (add-hook 'c++-mode 'pretty-mode/c++)
    #+END_SRC
*** Emacs Lisp
    #+BEGIN_SRC emacs-lisp
    (defun pretty-mode/emacs-lisp ()
      "Prettify symbols in Emacs Lisp mode."
      (setq prettify-symbols-alist
            '(("lambda" . ?λ)
              ("defun"  . ?ϝ)
              ("!="     . ?≠)
              ("<="     . ?≤)
              (">="     . ?≥))))

    (add-hook 'emacs-lisp-mode-hook 'pretty-mode/emacs-lisp)
    #+END_SRC
*** Haskell
    #+BEGIN_SRC emacs-lisp
    (defun pretty-mode/haskell ()
      (setq prettify-symbols-alist
            '(
              ("&&" . ?∧)
              ("++" . ?⧺)
              ("+++" . ?⧻)
              ("-->" . ?⟶)
              ("->" . ?→)
              ("..." . ?…)
              ("/<" . ?≮)
              ("/=" . ?≠)
              ("/>" . ?≯)
              ("::" . ?∷)
              (":=" . ?≔)
              ("<*>" . ?⊛)
              ("<-" . ?←)
              ("<--" . ?⟵)
              ("<-->" . ?⟷)
              ("<->" . ?↔)
              ("<<" . ?≪)
              ("<<<" . ?⋘)
              ("<=" . ?≤)
              ("<==" . ?⟸)
              ("<==>" . ?⟺)
              ("<=>" . ?⇔)
              ("<|" . ?⊲)
              ("=:" . ?≕)
              ("==" . ?≡)
              ("==>" . ?⟹)
              ("=>" . ?⇒)
              ("=?" . ?≟)
              ("=def" . ?≝)
              ("><" . ?⋈)
              (">=" . ?≥)
              (">>" . ?≫)
              (">>>" . ?⋙)
              ("elem" . ?∈)
              ("empty" . ?∅)
              ("intersection" . ?∩)
              ("isProperSubsetOf" . ?⊂)
              ("isSubsetOf" . ?⊆)
              ("mappend" . ?⊕)
              ("member" . ?∈)
              ("mempty" . ?∅)
              ("not" . ?¬)
              ("notElem" . ?∉)
              ("notMember" . ?∉)
              ("undefined" . ?⊥)
              ("union" . ?∪)
              ("|>" . ?⊳)
              ("||" . ?∨)
              )))

    (add-hook 'haskell-mode-hook 'pretty-mode/haskell)
    #+END_SRC
*** Fortran
    #+BEGIN_SRC emacs-lisp
    (defun pretty-mode/f90 ()
      "Prettify symbols in Fortran mode."
      (setq prettify-symbols-alist
            (append prettify-symbols-alist
                    '((".not." . ?¬)
                      (".and." . ?∧)
                      (".or."  . ?∨)))))

    (add-hook 'f90-mode-hook 'pretty-mode/f90)
    #+END_SRC
*** Python
    #+BEGIN_SRC emacs-lisp
    (defun pretty-mode/add-greek ()
      " add prettified versions of greek letters"
      (setq prettify-symbols-alist
            (append prettify-symbols-alist
                    '(("alpha"   . ?α)
                      ("beta"    . ?β)
                      ("gamma"   . ?γ)
                      ("delta"   . ?δ)
                      ("epsilon" . ?ε)
                      ("zeta"    . ?ζ)
                      ("eta"     . ?η)
                      ("theta"   . ?θ)))))

    (defun pretty-mode/python ()
      "Prettify symbols in python mode."
      (progn
        (setq prettify-symbols-alist
              '(("lambda" . ?λ)
                ("def"    . ?ϝ)
                ("!="     . ?≠)
                ("<="     . ?≤)
                (">="     . ?≥)
                ("in"     . ?∈)
                ("not in" . ?∉)
                ("for"    . ?∀)
                ("or"     . ?∨)
                ("and"    . ?∧)
                ("not"    . ?¬)
                ("->"     . ?→)))
        (pretty-mode/add-greek)))

    (add-hook 'python-mode-hook 'pretty-mode/python)
    #+END_SRC

* Playerctl
  #+BEGIN_SRC emacs-lisp
  (defun playerctl/command (command message)
    "Call playerctl asynchronously and display a message."
    (if (executable-find "playerctl")
        (progn
          (start-process "elplayerctl" nil "playerctl" command)
          (message message))
      (message "playerctl not available")))

  (defun song-pause()
    "Pause playback using playerctl"
    (interactive)
    (playerctl/command "play-pause" "Toggle playback"))

  (defun song-next()
    "Skip to next song using playerctl"
    (interactive)
    (playerctl/command "next" "Next song"))

  (defun song-prev()
    "Go back to previous song using playerctl"
    (interactive)
    (playerctl/command "previous" "Previous song"))

  (defun song-stop()
    "Stop playback using playerctl"
    (interactive)
    (playerctl/command "stop" "Stop music"))
  #+END_SRC

* Helm

#+BEGIN_SRC emacs-lisp
  (use-package helm)
  (use-package helm-projectile
    :config
    (setq projectile-completion-system 'helm)
    (define-key evil-normal-state-map (kbd "C-p") 'helm-browse-project)
    :init
    (helm-projectile-on))
#+END_SRC

